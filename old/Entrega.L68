0000100C Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/5/2024 21:25:59

00000000                             1  *------------------------------------------------
00000000                             2  * Titulo : P1 (2023-2024) - Sieve of Eratosthenes
00000000                             3  * Autores: Alumno 1 y Alumno 2
00000000                             4  *------------------------------------------------
00001000                             5      ORG $1000
00001000  =0000000A                  6  N: EQU 10
00001000                             7  P: DS.B N
0000100A                             8      DS.W 0
0000100A                             9  C: DS.W 1
0000100C                            10  *-------------Mis-Variables----------------------
0000100C                            11  *------------------------------------------------
0000100C                            12  START:                  ; first instruction of program
0000100C                            13  *Generamos la lista de numeros donde buscaremos los primos.
0000100C  123C 000A                 14      MOVE.B #N,D1
00001010  5301                      15      SUBQ.B #1,D1
00001012  41F8 1000                 16      LEA P,A0
00001016  103C 0001                 17      MOVE.B #1,D0
0000101A                            18  GL:     *Generacion de lista
0000101A  10C0                      19      MOVE.B D0, (A0)+
0000101C  5200                      20      ADDQ.B #1,D0
0000101E  51C9 FFFA                 21      DBRA D1,GL
00001022  4281                      22      CLR.L D1 *Limpiamos el registro D1 para evitar problemas problemas durante la ejecucion
00001024  5603                      23      ADDQ.B #3,D3
00001026  183C 000A                 24      MOVE.B #N,D4
0000102A  9803                      25      SUB.B D3,D4
0000102C  41F8 1000                 26      LEA P,A0
00001030  47F8 100A                 27      LEA C,A3 *ALMACENAMOS C EN A3
00001034  5242                      28      ADDQ #1,D2
00001036                            29  BucleDivisor:
00001036  5248                      30      ADDQ #1,A0
00001038  1210                      31      MOVE.B (A0),D1
0000103A  4A01                      32      TST.B D1 *Evitamos que el divisor pueda llegar a ser 0
0000103C  6700 002E                 33      BEQ DESCARTE
00001040  43F8 1000                 34      LEA P,A1
00001044  7A0A                      35      MOVE.L #N,D5 *Uso un long para sobre escribir los bits residuales
00001046                            36  BucleDividendo:
00001046  5249                      37      ADDQ #1,A1
00001048  1011                      38      MOVE.B (A1),D0
0000104A  4A00                      39      TST.B D0 *Comprovamos que D0 no es igual a 0
0000104C  6700 001A                 40      BEQ CERO
00001050  B240                      41      CMP.W D0,D1 *Comaprovamos que el divisor y el dividendo no son iguales
00001052  6700 0014                 42      BEQ CERO
00001056  80C1                      43      DIVU.W D1,D0 *Dividimos los dos numeros
00001058  E088                      44      LSR.L #8,D0 *Realizamos la operacion de LSR dos veces para moverlo 16 bits
0000105A  E088                      45      LSR.L #8,D0 *Lo realizo dos veces no me ha quedado muy claro si es por deficiencia de 68K o del simulador
0000105C  B07C 0000                 46      CMP.W #0,D0
00001060  6E00 0006                 47      BGT CERO *En caso de que D0 sea superior  a 0 nos saltamos la siguiente instrucion
00001064  12BC 0000                 48              MOVE.B #0,(A1)
00001068                            49  CERO:
00001068  51CD FFDC                 50      DBRA D5,BucleDividendo
0000106C                            51  DESCARTE:
0000106C  51CC FFC8                 52      DBRA D4,BucleDivisor
00001070                            53      *Vamos a contar todos los numeros diferentes a 0 (primos)
00001070  4282                      54      CLR.L D2 *Limpiamos d2
00001072  41F8 1000                 55      LEA P,A0
00001076  123C 000A                 56          MOVE.B #N,D1
0000107A  5242                      57          ADDQ #1,D2
0000107C                            58  CONTAR:
0000107C  1010                      59          MOVE.B (A0),D0
0000107E  B07C 0000                 60          CMP.W #0,D0 *Comparamos si el componente interno de D0 es igual a 0
00001082  6700 0004                 61          BEQ NOCONTAR *En caso de que D0 !=0 nos saltamos la sigueite instruccion
00001086  5242                      62          ADDQ #1,D2
00001088                            63  NOCONTAR:
00001088  5248                      64          ADDQ #1,A0 *Movemos el puntero al sigueite elemento
0000108A  51C9 FFF0                 65      DBRA  D1,CONTAR
0000108E  3482                      66      MOVE.W D2,(A2) *Almacenamos el valor de nuestro contador a C
00001090  FFFF FFFF                 67      SIMHALT             ; halt simulator
00001094                            68  
00001094                            69      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BUCLEDIVIDENDO      1046
BUCLEDIVISOR        1036
C                   100A
CERO                1068
CONTAR              107C
DESCARTE            106C
GL                  101A
N                   A
NOCONTAR            1088
P                   1000
START               100C
